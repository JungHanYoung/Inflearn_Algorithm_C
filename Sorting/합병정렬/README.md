## 합병 정렬

### 분할정복법 (Dvide and Conquer)

- 분할: 해결하고자 하는 문제를 작은 크기의 동일한 문제들로 분할
- 정복: 각각의 작은 문제를 순환적으로 해결
- 합병: 작은 문제의 해를 합하여(merge) 원래 문제에 대한 해를 구함.

### 합병 정렬 개념.

- 데이터가 저장된 배열을 반으로 나눔.(divide)
- 각각을 순환적으로 정렬.(recursion)
- 정렬된 두 개의 배열을 합쳐 전체를 정렬.(merge)

### 정리

- 데이터를 반으로 나누다 보면 1개의 데이터만이 남는다.
- 1개의 데이터부터 합병정렬을 하게된다. (그래서 recursion)
- 합병 직전의 데이터는 정렬이 되어있는 것으로 간주한다.
- 합병(merge)과정의 코딩만 넣어주면 된다.

#### 합병과정의 코딩

- 2개의 데이터를 합병하기 전에 각 데이터의 첫번째 인덱스부터 비교.
- 첫번째 데이터의 인덱스 순환 변수 i
- 두번째 데이터의 인덱스 순환 변수 j

~~~
A[i] < A[j]이면..
새로운 배열[k] = A[i]
i++;
k++;
~~~

### 수도코딩.

~~~
mergeSort(A[], p, r) {

    if(p < r) {
        q = 배열의 중간지점.
        mergeSort(A, p, q); 배열의 시작부터 중간까지
        mergeSort(A, q+1, r); 배열의 중간부터 마지막까지
        merge(A, p, q, r);
    }
}

merge(A[], p, q, r) {
    정렬된 두 배열 A[p...q]와 A[q+1...r]을 가지고 정렬된 배열을 만든다.
}
~~~

### 실행 결과

~~~
===== 합병정렬 =====
정렬 전..
5 4 7 2 1 8 2 3 4 9 

정렬 후..
1 2 2 3 4 4 5 7 8 9 
~~~



